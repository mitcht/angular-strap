{"version":3,"sources":["modules/tooltip.js"],"names":["angular","target","provider","placement","this","defaults","templateUrl","template","contentTemplate","trigger","keyboard","html","show","title","type","delay","autoClose","bsEnabled","viewport","selector","padding","$get","String","htmlReplaceRegExp","$body","options","$tooltip","extend","config","split","enterAnimateCallback","scope","$emit","prefixEvent","leaveAnimateCallback","_tipToHide","leave","$isShown","element","blur","tipElement","nodeName","forEach","triggers","on","toggle","unbindTriggerEvents","enter","i","length","off","bindKeyboardEvents","$onKeyUp","isTouch","$onFocusElementMouseDown","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","$timeout","hide","unbindAutoCloseEvents","stopEventPropagation","event","getPosition","$element","rect","stopPropagation","width","elRect","height","p","top","left","dimensions","offset","el","scroll","isBody","document","documentElement","$window","getCalculatedOffset","position","actualWidth","actualHeight","outerDims","clientWidth","innerHeight","tip","marginTop","parseInt","using","props","css","isNaN","right","marginLeft","setOffset","delta","getViewportAdjustedDelta","isVertical","replaceArrow","arrowDelta","test","arrowOffsetPosition","viewportDimensions","$viewport","topEdgeOffset","bottomEdgeOffset","viewportPadding","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","findElement","$arrow","clearTimeout","timeout","tipScope","$destroy","$$phase","$options","$promise","$bsCompiler","compile","$scope","$new","$rootScope","toLowerCase","$id","attr","map","parseFloat","$sce","trustAsHtml","$setEnabled","$$postDigest","id","$hide","setEnabled","isEnabled","compileData","promise","then","init","container","tipContainer","bindTriggerEvents","isElement","destroyTipElement","hoverState","parent","after","lastChild","display","visibility","link","clonedElement","safeDigest","version","minor","addClass","animation","$animate","customClass","$$rAF","$applyPlacement","focus","_blur","replace","elementPosition","autoPlace","autoToken","viewportPosition","originalPlacement","indexOf","tipHeight","removeClass","tipPosition","applyPlacement","tipWidth","evt","preventDefault","fetchTemplate","fetchPromises","cache","$templateCache","res","isString","directive","$location","restrict","falseValueRegExp","transclusion","dataTarget","key","isDefined","hasOwnProperty","oldValue","tooltip","$observe","newValue","bsTooltip","$watch","isObject","bsShow","match","setViewport","$on","destroy"],"mappings":"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","file":"modules/tooltip.min.js","sourcesContent":["'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$tooltip', function() {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'tooltip',\r\n      prefixEvent: 'tooltip',\r\n      container: false,\r\n      target: false,\r\n      placement: 'top',\r\n      templateUrl: 'tooltip/tooltip.tpl.html',\r\n      template: '',\r\n      contentTemplate: false,\r\n      trigger: 'hover focus',\r\n      keyboard: false,\r\n      html: false,\r\n      show: false,\r\n      title: '',\r\n      type: '',\r\n      delay: 0,\r\n      autoClose: false,\r\n      bsEnabled: true,\r\n      viewport: {\r\n       selector: 'body',\r\n       padding: 0\r\n      }\r\n    };\r\n\r\n    this.$get = function($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\r\n\r\n      var trim = String.prototype.trim;\r\n      var isTouch = 'createTouch' in $window.document;\r\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\r\n      var $body = angular.element($window.document);\r\n\r\n      function TooltipFactory(element, config) {\r\n\r\n        var $tooltip = {};\r\n\r\n        // Common vars\r\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\r\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\r\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n\r\n        var nodeName = element[0].nodeName.toLowerCase();\r\n        if(options.delay && angular.isString(options.delay)) {\r\n          var split = options.delay.split(',').map(parseFloat);\r\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\r\n        }\r\n\r\n        // Store $id to identify the triggering element in events\r\n        // give priority to options.id, otherwise, try to use\r\n        // element id if defined\r\n        $tooltip.$id = options.id || element.attr('id') || '';\r\n\r\n        // Support scope as string options\r\n        if(options.title) {\r\n          scope.title = $sce.trustAsHtml(options.title);\r\n        }\r\n\r\n        // Provide scope helpers\r\n        scope.$setEnabled = function(isEnabled) {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.setEnabled(isEnabled);\r\n          });\r\n        };\r\n        scope.$hide = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.hide();\r\n          });\r\n        };\r\n        scope.$show = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.show();\r\n          });\r\n        };\r\n        scope.$toggle = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.toggle();\r\n          });\r\n        };\r\n        // Publish isShown as a protected var on scope\r\n        $tooltip.$isShown = scope.$isShown = false;\r\n\r\n        // Private vars\r\n        var timeout, hoverState;\r\n\r\n        // Fetch, compile then initialize tooltip\r\n        var compileData, tipElement, tipContainer, tipScope;\r\n        promise.then(function(data) {\r\n          compileData = data;\r\n          $tooltip.init();\r\n        });\r\n\r\n        $tooltip.init = function() {\r\n\r\n          // Options: delay\r\n          if (options.delay && angular.isNumber(options.delay)) {\r\n            options.delay = {\r\n              show: options.delay,\r\n              hide: options.delay\r\n            };\r\n          }\r\n\r\n          // Replace trigger on touch devices ?\r\n          // if(isTouch && options.trigger === defaults.trigger) {\r\n          //   options.trigger.replace(/hover/g, 'click');\r\n          // }\r\n\r\n          // Options : container\r\n          if(options.container === 'self') {\r\n            tipContainer = element;\r\n          } else if(angular.isElement(options.container)) {\r\n            tipContainer = options.container;\r\n          } else if(options.container) {\r\n            tipContainer = findElement(options.container);\r\n          }\r\n\r\n          // Options: trigger\r\n          bindTriggerEvents();\r\n\r\n          // Options: target\r\n          if(options.target) {\r\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\r\n          }\r\n\r\n          // Options: show\r\n          if(options.show) {\r\n            scope.$$postDigest(function() {\r\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $tooltip.destroy = function() {\r\n\r\n          // Unbind events\r\n          unbindTriggerEvents();\r\n\r\n          // Remove element\r\n          destroyTipElement();\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n\r\n        };\r\n\r\n        $tooltip.enter = function() {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'in';\r\n          if (!options.delay || !options.delay.show) {\r\n            return $tooltip.show();\r\n          }\r\n\r\n          timeout = setTimeout(function() {\r\n            if (hoverState ==='in') $tooltip.show();\r\n          }, options.delay.show);\r\n\r\n        };\r\n\r\n        $tooltip.show = function() {\r\n          if (!options.bsEnabled || $tooltip.$isShown) return;\r\n\r\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\r\n          var parent, after;\r\n          if (options.container) {\r\n            parent = tipContainer;\r\n            if (tipContainer[0].lastChild) {\r\n              after = angular.element(tipContainer[0].lastChild);\r\n            } else {\r\n              after = null;\r\n            }\r\n          } else {\r\n            parent = null;\r\n            after = element;\r\n          }\r\n\r\n\r\n          // Hide any existing tipElement\r\n          if(tipElement) destroyTipElement();\r\n          // Fetch a cloned element linked from template\r\n          tipScope = $tooltip.$scope.$new();\r\n          tipElement = $tooltip.$element = compileData.link(tipScope, function(clonedElement, scope) {});\r\n\r\n          // Set the initial positioning.  Make the tooltip invisible\r\n          // so IE doesn't try to focus on it off screen.\r\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\r\n\r\n          // Options: animation\r\n          if(options.animation) tipElement.addClass(options.animation);\r\n          // Options: type\r\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\r\n          // Options: custom classes\r\n          if(options.customClass) tipElement.addClass(options.customClass);\r\n\r\n          // Append the element, without any animations.  If we append\r\n          // using $animate.enter, some of the animations cause the placement\r\n          // to be off due to the transforms.\r\n          after ? after.after(tipElement) : parent.prepend(tipElement);\r\n\r\n          $tooltip.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n\r\n          // Now, apply placement\r\n          $tooltip.$applyPlacement();\r\n\r\n          // Once placed, animate it.\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if(angular.version.minor <= 2) {\r\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\r\n          } else {\r\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\r\n          }\r\n          safeDigest(scope);\r\n\r\n          $$rAF(function () {\r\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\r\n            if(tipElement) tipElement.css({visibility: 'visible'});\r\n          });\r\n\r\n          // Bind events\r\n          if(options.keyboard) {\r\n            if(options.trigger !== 'focus') {\r\n              $tooltip.focus();\r\n            }\r\n            bindKeyboardEvents();\r\n          }\r\n\r\n          if(options.autoClose) {\r\n            bindAutoCloseEvents();\r\n          }\r\n\r\n        };\r\n\r\n        function enterAnimateCallback() {\r\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\r\n        }\r\n\r\n        $tooltip.leave = function() {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'out';\r\n          if (!options.delay || !options.delay.hide) {\r\n            return $tooltip.hide();\r\n          }\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'out') {\r\n              $tooltip.hide();\r\n            }\r\n          }, options.delay.hide);\r\n\r\n        };\r\n\r\n        var _blur;\r\n        var _tipToHide;\r\n        $tooltip.hide = function(blur) {\r\n\r\n          if(!$tooltip.$isShown) return;\r\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\r\n\r\n          // store blur value for leaveAnimateCallback to use\r\n          _blur = blur;\r\n\r\n          // store current tipElement reference to use\r\n          // in leaveAnimateCallback\r\n          _tipToHide = tipElement;\r\n\r\n          // Support v1.2+ $animate\r\n          // https://github.com/angular/angular.js/issues/11713\r\n          if(angular.version.minor <= 2) {\r\n            $animate.leave(tipElement, leaveAnimateCallback);\r\n          } else {\r\n            $animate.leave(tipElement).then(leaveAnimateCallback);\r\n          }\r\n\r\n          $tooltip.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          if(options.keyboard && tipElement !== null) {\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if(options.autoClose && tipElement !== null) {\r\n            unbindAutoCloseEvents();\r\n          }\r\n        };\r\n\r\n        function leaveAnimateCallback() {\r\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\r\n\r\n          // check if current tipElement still references\r\n          // the same element when hide was called\r\n          if (tipElement === _tipToHide) {\r\n            // Allow to blur the input when hidden, like when pressing enter key\r\n            if(_blur && options.trigger === 'focus') {\r\n              return element[0].blur();\r\n            }\r\n\r\n            // clean up child scopes\r\n            destroyTipElement();\r\n          }\r\n        }\r\n\r\n        $tooltip.toggle = function() {\r\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\r\n        };\r\n\r\n        $tooltip.focus = function() {\r\n          tipElement[0].focus();\r\n        };\r\n\r\n        $tooltip.setEnabled = function(isEnabled) {\r\n          options.bsEnabled = isEnabled;\r\n        };\r\n\r\n        $tooltip.setViewport = function(viewport) {\r\n          options.viewport = viewport;\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $tooltip.$applyPlacement = function() {\r\n          if(!tipElement) return;\r\n\r\n          // Determine if we're doing an auto or normal placement\r\n          var placement = options.placement,\r\n              autoToken = /\\s?auto?\\s?/i,\r\n              autoPlace  = autoToken.test(placement);\r\n\r\n          if (autoPlace) {\r\n            placement = placement.replace(autoToken, '') || defaults.placement;\r\n          }\r\n\r\n          // Need to add the position class before we get\r\n          // the offsets\r\n          tipElement.addClass(options.placement);\r\n\r\n          // Get the position of the target element\r\n          // and the height and width of the tooltip so we can center it.\r\n          var elementPosition = getPosition(),\r\n              tipWidth = tipElement.prop('offsetWidth'),\r\n              tipHeight = tipElement.prop('offsetHeight');\r\n\r\n          // Refresh viewport position\r\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\r\n\r\n          // If we're auto placing, we need to check the positioning\r\n          if (autoPlace) {\r\n            var originalPlacement = placement;\r\n            var viewportPosition = getPosition($tooltip.$viewport);\r\n\r\n            // Determine if the vertical placement\r\n            if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\r\n              placement = originalPlacement.replace('bottom', 'top');\r\n            } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < viewportPosition.top) {\r\n              placement = originalPlacement.replace('top', 'bottom');\r\n            }\r\n\r\n            // Determine the horizontal placement\r\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\r\n            // and flow in the opposite direction of their placement.\r\n            if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&\r\n                elementPosition.right + tipWidth > viewportPosition.width) {\r\n\r\n              placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\r\n            } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&\r\n                elementPosition.left - tipWidth < viewportPosition.left) {\r\n\r\n              placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\r\n            }\r\n\r\n            tipElement.removeClass(originalPlacement).addClass(placement);\r\n          }\r\n\r\n          // Get the tooltip's top and left coordinates to center it with this directive.\r\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\r\n          applyPlacement(tipPosition, placement);\r\n        };\r\n\r\n        $tooltip.$onKeyUp = function(evt) {\r\n          if (evt.which === 27 && $tooltip.$isShown) {\r\n            $tooltip.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusKeyUp = function(evt) {\r\n          if (evt.which === 27) {\r\n            element[0].blur();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusElementMouseDown = function(evt) {\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Some browsers do not auto-focus buttons (eg. Safari)\r\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\r\n        };\r\n\r\n        // bind/unbind events\r\n        function bindTriggerEvents() {\r\n          var triggers = options.trigger.split(' ');\r\n          angular.forEach(triggers, function(trigger) {\r\n            if(trigger === 'click') {\r\n              element.on('click', $tooltip.toggle);\r\n            } else if(trigger !== 'manual') {\r\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n            }\r\n          });\r\n        }\r\n\r\n        function unbindTriggerEvents() {\r\n          var triggers = options.trigger.split(' ');\r\n          for (var i = triggers.length; i--;) {\r\n            var trigger = triggers[i];\r\n            if(trigger === 'click') {\r\n              element.off('click', $tooltip.toggle);\r\n            } else if(trigger !== 'manual') {\r\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n            }\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents() {\r\n          if(options.trigger !== 'focus') {\r\n            tipElement.on('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.on('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents() {\r\n          if(options.trigger !== 'focus') {\r\n            tipElement.off('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.off('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        var _autoCloseEventsBinded = false;\r\n        function bindAutoCloseEvents() {\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function() {\r\n            // Stop propagation when clicking inside tooltip\r\n            tipElement.on('click', stopEventPropagation);\r\n\r\n            // Hide when clicking outside tooltip\r\n            $body.on('click', $tooltip.hide);\r\n\r\n            _autoCloseEventsBinded = true;\r\n          }, 0, false);\r\n        }\r\n\r\n        function unbindAutoCloseEvents() {\r\n          if (_autoCloseEventsBinded) {\r\n            tipElement.off('click', stopEventPropagation);\r\n            $body.off('click', $tooltip.hide);\r\n            _autoCloseEventsBinded = false;\r\n          }\r\n        }\r\n\r\n        function stopEventPropagation(event) {\r\n          event.stopPropagation();\r\n        }\r\n\r\n        // Private methods\r\n\r\n        function getPosition($element) {\r\n          $element = $element || (options.target || element);\r\n\r\n          var el = $element[0],\r\n              isBody = el.tagName === 'BODY';\r\n\r\n          var elRect = el.getBoundingClientRect();\r\n          var rect = {};\r\n\r\n          // IE8 has issues with angular.extend and using elRect directly.\r\n          // By coping the values of elRect into a new object, we can continue to use extend\r\n          for (var p in elRect) {\r\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\r\n            rect[p] = elRect[p];\r\n          }\r\n\r\n          if (rect.width === null) {\r\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\r\n            rect = angular.extend({}, rect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });\r\n          }\r\n          var elOffset = isBody ? { top: 0, left: 0 } : dimensions.offset(el),\r\n              scroll = { scroll:  isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0 },\r\n              outerDims = isBody ? { width: document.documentElement.clientWidth, height: $window.innerHeight } : null;\r\n\r\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\r\n        }\r\n\r\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\r\n          var offset;\r\n          var split = placement.split('-');\r\n\r\n          switch (split[0]) {\r\n          case 'right':\r\n            offset = {\r\n              top: position.top + position.height / 2 - actualHeight / 2,\r\n              left: position.left + position.width\r\n            };\r\n            break;\r\n          case 'bottom':\r\n            offset = {\r\n              top: position.top + position.height,\r\n              left: position.left + position.width / 2 - actualWidth / 2\r\n            };\r\n            break;\r\n          case 'left':\r\n            offset = {\r\n              top: position.top + position.height / 2 - actualHeight / 2,\r\n              left: position.left - actualWidth\r\n            };\r\n            break;\r\n          default:\r\n            offset = {\r\n              top: position.top - actualHeight,\r\n              left: position.left + position.width / 2 - actualWidth / 2\r\n            };\r\n            break;\r\n          }\r\n\r\n          if(!split[1]) {\r\n            return offset;\r\n          }\r\n\r\n          // Add support for corners @todo css\r\n          if(split[0] === 'top' || split[0] === 'bottom') {\r\n            switch (split[1]) {\r\n            case 'left':\r\n              offset.left = position.left;\r\n              break;\r\n            case 'right':\r\n              offset.left =  position.left + position.width - actualWidth;\r\n            }\r\n          } else if(split[0] === 'left' || split[0] === 'right') {\r\n            switch (split[1]) {\r\n            case 'top':\r\n              offset.top = position.top - actualHeight;\r\n              break;\r\n            case 'bottom':\r\n              offset.top = position.top + position.height;\r\n            }\r\n          }\r\n\r\n          return offset;\r\n        }\r\n\r\n        function applyPlacement(offset, placement) {\r\n          var tip = tipElement[0],\r\n              width = tip.offsetWidth,\r\n              height = tip.offsetHeight;\r\n\r\n          // manually read margins because getBoundingClientRect includes difference\r\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10),\r\n              marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\r\n\r\n          // we must check for NaN for ie 8/9\r\n          if (isNaN(marginTop)) marginTop  = 0;\r\n          if (isNaN(marginLeft)) marginLeft = 0;\r\n\r\n          offset.top  = offset.top + marginTop;\r\n          offset.left = offset.left + marginLeft;\r\n\r\n          // dimensions setOffset doesn't round pixel values\r\n          // so we use setOffset directly with our own function\r\n          dimensions.setOffset(tip, angular.extend({\r\n            using: function (props) {\r\n              tipElement.css({\r\n                top: Math.round(props.top) + 'px',\r\n                left: Math.round(props.left) + 'px',\r\n                right: ''\r\n              });\r\n            }\r\n          }, offset), 0);\r\n\r\n          // check to see if placing tip in new offset caused the tip to resize itself\r\n          var actualWidth = tip.offsetWidth,\r\n              actualHeight = tip.offsetHeight;\r\n\r\n          if (placement === 'top' && actualHeight !== height) {\r\n            offset.top = offset.top + height - actualHeight;\r\n          }\r\n\r\n          // If it's an exotic placement, exit now instead of\r\n          // applying a delta and changing the arrow\r\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\r\n\r\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\r\n\r\n          if (delta.left) {\r\n            offset.left += delta.left;\r\n          } else {\r\n            offset.top += delta.top;\r\n          }\r\n\r\n          dimensions.setOffset(tip, offset);\r\n\r\n          if (/top|right|bottom|left/.test(placement)) {\r\n            var isVertical = /top|bottom/.test(placement),\r\n                arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight,\r\n                arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\r\n\r\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\r\n          }\r\n        }\r\n\r\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\r\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\r\n          var delta = {top: 0, left: 0};\r\n          if (!$tooltip.$viewport) return delta;\r\n\r\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\r\n          var viewportDimensions = getPosition($tooltip.$viewport);\r\n\r\n          if (/right|left/.test(placement)) {\r\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\r\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\r\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\r\n              delta.top = viewportDimensions.top - topEdgeOffset;\r\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\r\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\r\n            }\r\n          } else {\r\n            var leftEdgeOffset = position.left - viewportPadding;\r\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\r\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\r\n              delta.left = viewportDimensions.left - leftEdgeOffset;\r\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\r\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\r\n            }\r\n          }\r\n\r\n          return delta;\r\n        }\r\n\r\n        function replaceArrow(delta, dimension, isHorizontal) {\r\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\r\n\r\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\r\n                .css(isHorizontal ? 'top' : 'left', '');\r\n        }\r\n\r\n        function destroyTipElement() {\r\n          // Cancel pending callbacks\r\n          clearTimeout(timeout);\r\n\r\n          if($tooltip.$isShown && tipElement !== null) {\r\n            if(options.autoClose) {\r\n              unbindAutoCloseEvents();\r\n            }\r\n\r\n            if(options.keyboard) {\r\n              unbindKeyboardEvents();\r\n            }\r\n          }\r\n\r\n          if(tipScope) {\r\n            tipScope.$destroy();\r\n            tipScope = null;\r\n          }\r\n\r\n          if(tipElement) {\r\n            tipElement.remove();\r\n            tipElement = $tooltip.$element = null;\r\n          }\r\n        }\r\n\r\n        return $tooltip;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest(scope) {\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n      }\r\n\r\n      function findElement(query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      var fetchPromises = {};\r\n      function fetchTemplate(template) {\r\n        if(fetchPromises[template]) return fetchPromises[template];\r\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\r\n          return res.data;\r\n        }));\r\n      }\r\n\r\n      return TooltipFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTooltip', function($window, $location, $sce, $tooltip, $$rAF) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink(scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function(key) {\r\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // use string regex match boolean attr falsy values, leave truthy values be\r\n        var falseValueRegExp = /^(false|0|)$/i;\r\n        angular.forEach(['html', 'container'], function(key) {\r\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\r\n            options[key] = false;\r\n        });\r\n\r\n        // should not parse target attribute (anchor tag), only data-target #1454\r\n        var dataTarget = element.attr('data-target');\r\n        if(angular.isDefined(dataTarget)) {\r\n          if(falseValueRegExp.test(dataTarget))\r\n            options.target = false;\r\n          else\r\n            options.target = dataTarget;\r\n        }\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.hasOwnProperty('title')){\r\n          scope.title = '';\r\n        }\r\n\r\n        // Observe scope attributes for change\r\n        attr.$observe('title', function(newValue) {\r\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\r\n            var oldValue = scope.title;\r\n            scope.title = $sce.trustAsHtml(newValue);\r\n            angular.isDefined(oldValue) && $$rAF(function() {\r\n              tooltip && tooltip.$applyPlacement();\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\r\n          if(angular.isObject(newValue)) {\r\n            angular.extend(scope, newValue);\r\n          } else {\r\n            scope.title = newValue;\r\n          }\r\n          angular.isDefined(oldValue) && $$rAF(function() {\r\n            tooltip && tooltip.$applyPlacement();\r\n          });\r\n        }, true);\r\n\r\n        // Visibility binding support\r\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\r\n          if(!tooltip || !angular.isDefined(newValue)) return;\r\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\r\n          newValue === true ? tooltip.show() : tooltip.hide();\r\n        });\r\n\r\n        // Enabled binding support\r\n        attr.bsEnabled && scope.$watch(attr.bsEnabled, function(newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\r\n          if(!tooltip || !angular.isDefined(newValue)) return;\r\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\r\n          newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\r\n        });\r\n\r\n        // Viewport support\r\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\r\n          if(!tooltip || !angular.isDefined(newValue)) return;\r\n          tooltip.setViewport(newValue);\r\n        });\r\n\r\n        // Initialize popover\r\n        var tooltip = $tooltip(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function() {\r\n          if(tooltip) tooltip.destroy();\r\n          options = null;\r\n          tooltip = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n"],"sourceRoot":"/source/"}